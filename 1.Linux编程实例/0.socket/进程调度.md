### 进程调度

- 进程调度是一个内核子系统
- 进程调度的主要任务是决定哪一个“就绪”状态的进程来执行
- 就绪进程是非阻塞进程
- 阻塞进程就是正在睡眠的进程，需要内核呼唤的进程

**三态模型**

![image](https://github.com/hello-sources/Relative_Things/blob/master/img/Linux_OS_img/%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.png?raw=true)

**从单任务到多任务**

- DOS是单任务操作系统，每次只运行一个进程
- 在单处理器操作系统中，进程交错运行，从用户的角度来看，仿佛是一个多任务在同时运行
- 在多处理器的操作系统中，在不同的处理器上可以同时运行不同的任务，做到真正的**并行**运行（并发就是轮流处理多个任务）
- 多为调度，就是运行哪一个进行，运行多久？



**协同式与抢占式**

- 协同式

> 进程会一直运行直到结束
>
> 操作系统不做任何干预

- 抢占式

> 调度器决定进程何时结束并执行另外一个进程，这叫做抢占。
>
> 进程被抢占前运行的时间称为处理该进程的时间片
>
> 调度器给每个进程分配一个处理器时间片



**时间片长短**对于系统全局行为以及性能都是十分重要的

- **过长**

> 1. 提升系统吞吐率以及全局性能
> 2. 进程执行所需要等待的时间较长，降低了并发运行
> 3. 用户会感到明显的延迟

- **过短**

> 1. 提升交换性能
> 2. 大量时间都花在调度上
> 3. 时间局限性带来的性能提升大打折扣

- 解决时间片长短问题：**不用时间片**



**IO约束型与处理器约束型**

- 一直消耗完可用时间片的进程为处理器约束型进程

> 需要获取大量CPU资源
>
> 消耗掉调度器分配的全部CPU

- 多数时间处于阻塞状态的或者等待资源的进程为IO约束型进程

> 经常阻塞在文件IO操作上：文件，网络，键盘，鼠标
>
> 也可能除了请求内核执行IO操作之外什么也不做



**抢占式调度**

- 传统UNIX进程调度内核给进程时间片，时间片用完了，挂起该进程，执行其他进程
- 如果此时系统中没有其他就绪的，，会给已经执行的进程重新划分时间片，并重新执行
- 进程创建和终止就是进入和退出就绪队列
- 如果有高优先级的进程 ，会优先运行这些进程，然后运行低优先级的进程
- 所有的进程都会有机会被运行





**完全公平调度器(Complete Fair Scheduler, CFS)**

- CFS给N个进程每个进程分别分配1/N 个处理器时间
- 通过**优先级**以及**权值**调整分配，默认优先级为0， 权值为1
- 优先级值设置越小（优先级越高），则权值越大，分配比例也越大
- 为了确定每一个进程真实的执行时间， 引入**目标延迟**，目标延迟是调度的固定周期

- 为了避免因为目标延迟设置过小导致每一个进程运行时间过短，引入**最小粒度**
- **公平性：每个进程都会得到处理器资源的“公平配额”**



